{"version":3,"file":"static/webpack/static/development/pages/index.js.a904f0579e9a373f7ae1.hot-update.js","sources":["webpack:///./components/OrnamentCanvas.tsx"],"sourcesContent":["import React, { useEffect } from \"react\";\n\nconst range = (start: number, end: number) =>\n  start + Math.random() * (end - start);\nconst rangeI = (start: number, end: number) => Math.floor(range(start, end));\nconst rnd = (n: number) => Math.random() * n;\nconst rndI = (n: number) => Math.floor(rnd(n));\n\nconst shuffle = (a: number[]) => {\n  var b = [];\n  while (a.length > 0) {\n    b.push(...a.splice(rndI(a.length)));\n  }\n  return b;\n};\n\nconst canvasSize = 250;\nconst count = 3;\nconst steps = 300;\nconst pi = Math.PI;\nconst pi2 = Math.PI * 2;\nconst pi05 = Math.PI * 0.5;\nconst step = pi2 / steps;\n\nconst picks = [rangeI(12, 16), rangeI(7, 11), rangeI(3, 5)];\nconst radius = [range(150, 170)];\nconst thickness = [rangeI(25, 40)];\nconst squeezeOffset = [rnd(pi2)];\n\nconst xxx = Math.max(0.005, rnd(0.01));\nconst squeezeSpeed = [xxx, xxx, -xxx];\n\nconst scale = canvasSize / 600;\nconst ampReduce = 40 * scale;\n\nconst lineWidth = shuffle([6 * 1.8, 7 * 1.8, 6 * 1.8]);\n\nconst drawLogo = (canvas: HTMLCanvasElement) => {\n  canvas.width = canvasSize - 20;\n  canvas.height = canvasSize - 20;\n  const ctx = canvas.getContext(\"2d\");\n  const x0 = canvas.width / 2;\n  const y0 = canvas.height / 2;\n\n  radius.push(radius[0]);\n  radius.push(radius[0] - range(0, 10));\n\n  thickness.push(thickness[0]);\n  thickness.push(rangeI(25, 35));\n\n  squeezeOffset.push(squeezeOffset[0] + pi);\n  squeezeOffset.push(squeezeOffset[0] - pi / 2);\n\n  const rotationOffset = squeezeOffset.slice();\n\n  let a = [radius, thickness, lineWidth];\n\n  for (let i = 0; i < a.length; i++) {\n    let b = a[i];\n    for (let j = 0; j < b.length; j++) {\n      b[j] *= scale;\n    }\n  }\n\n  const draw = () => {\n    if (!ctx) {\n      return;\n    }\n    ctx.clearRect(0, 0, canvasSize, canvasSize);\n    let x, y, r, a, o, t, s, g, p;\n    for (let j = 0; j < count; j++) {\n      ctx.beginPath();\n      ctx.lineWidth = lineWidth[j] * 1.6;\n      squeezeOffset[j] += squeezeSpeed[j];\n      rotationOffset[j] += squeezeSpeed[j];\n      o = squeezeOffset[j];\n      p = rotationOffset[j];\n      g = ctx.createLinearGradient(\n        x0 + radius[j] * Math.sin(pi05 + p),\n        y0 + radius[j] * Math.cos(pi05 + p),\n        x0 - radius[j] * Math.sin(pi05 + p),\n        y0 - radius[j] * Math.cos(pi05 + p)\n      );\n      g.addColorStop(0.4, \"rgba(255, 255, 255, 1.0)\");\n      g.addColorStop(1, \"rgba(255, 255, 255, 0.1)\");\n      ctx.strokeStyle = g;\n      for (let i = 0; i < steps; i++) {\n        a = i * step;\n        s = Math.cos(p + a);\n        a += 0.4 * Math.sin(o + a);\n        t = thickness[j] + ampReduce / 2;\n        r =\n          radius[j] -\n          ampReduce +\n          (t * (1 + Math.cos((i / steps) * pi2 * picks[j])) * (1.2 + s)) / 2;\n        x = x0 + r * Math.cos(a);\n        y = y0 + r * Math.sin(a);\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.closePath();\n      ctx.stroke();\n    }\n    window.requestAnimationFrame(draw);\n  };\n\n  draw();\n};\n\nexport const OrnamentCanvas: React.SFC = () => {\n  // const canvasRef = React.useRef(null);\n  const ornamentCanvas: React.RefObject<HTMLCanvasElement> = React.createRef();\n\n  useEffect(() => {\n    if (ornamentCanvas && ornamentCanvas.current) {\n      const canvas = ornamentCanvas.current;\n      drawLogo(canvas);\n      // const context = canvas.getContext(\"2d\");\n      // if (context) {\n      //   context.fillRect(0, 0, canvas.width, canvas.height);\n      // }\n    }\n  }, []);\n\n  return <canvas ref={ornamentCanvas} width={32} height={32} />;\n};\n\n// interface IOwnState {\n//   showString: boolean;\n//   secondsFromBd: number;\n// }\n\n// export class OrnamentCanvas extends React.Component<any, IOwnState> {\n//   // private ornamentCanvas?: HTMLCanvasElement;\n//   private ornamentCanvas: React.RefObject<\n//     HTMLCanvasElement\n//   > = React.createRef();\n\n//   // public readonly state: IOwnState = {\n//   //   showString: false,\n//   //   secondsFromBd: 0\n//   // };\n\n//   public componentDidMount() {\n//     if (this.ornamentCanvas) {\n//       drawLogo(this.ornamentCanvas as any);\n//     }\n//     // this.setState({ secondsFromBd: this.calcSecondsFromBd() });\n//     // this.secondsTimer = setInterval(() => {\n//     //   this.setState({ secondsFromBd: this.calcSecondsFromBd() });\n//     // }, 1000);\n//   }\n\n//   // public componentWillUnmount() {\n//   //   if (this.secondsTimer) {\n//   //     clearInterval(this.secondsTimer);\n//   //   }\n//   // }\n\n//   public render() {\n//     return (\n//       <>\n//         <canvas ref=\"ornamentCanvas\" className=\"or-logo\" />\n\n//         <style jsx>{`\n//           .or-logo {\n//             width: 68px;\n//             height: 68px;\n//           }\n//         `}</style>\n//       </>\n//     );\n//   }\n// }\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}